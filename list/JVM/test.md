# GC ----垃圾回收机制 
<!-- TOC -->
- [GC ----垃圾回收机制](#gc-----垃圾回收机制)auto   
  - [1. 堆的存储结构](#1-堆的存储结构)auto   
  - [2. 如何判定他为垃圾？](#2-如何判定他为垃圾)auto      
	     - [2.1 判断垃圾的算法](#21-判断垃圾的算法)auto          
	      	- [2.1.1 引用计数算法：](#211-引用计数算法)auto           
	        - [2.1.2. 可达性分析算法：](#212-可达性分析算法)auto      
 - [3. 垃圾回收的算法](#3-垃圾回收的算法)auto            
 		- [3.1 标记清除算法](#31-标记清除算法)auto          
   		- [3.2 复制算法（重要）](#32-复制算法重要)auto            
   		- [3.3 标记整理算法（重要）](#33-标记整理算法重要)auto            
   		- [3.4 分代收集算法](#34-分代收集算法)auto                
  		 - [3.4.1 分配存储机制](#341-分配存储机制)auto               
   			- [3.4.2 Minor GC回收机制（回收年轻代）](#342-minor-gc回收机制回收年轻代)
   			-                [3.4.3 为什么要创建两个survior区域 ？](#343-为什么要创建两个survior区域-)auto                
   			-                [3.4.4 常见性能调优参数](#344-常见性能调优参数)auto               
   			- [3.4.5 full GC与Major GC](#345-full-gc与major-gc)auto                
  		 - [3.4.6 触发full GC的条件](#346-触发full-gc的条件)auto        
	- [4. 垃圾收集器(收集算法的应用与强化)](#4-垃圾收集器收集算法的应用与强化)auto            
	   - [4.1 JVM运行模式](#41-jvm运行模式)auto            
		- [4.2 垃圾收集器之间的关系](#42-垃圾收集器之间的关系)auto            
		- [4.3 年轻代的收集器](#43-年轻代的收集器)auto                
			- [4.3.1 Serial收集器（使用复制算法）](#431-serial收集器使用复制算法)auto              
			- [4.3.2 ParNew收集器（使用复制算法）](#432-parnew收集器使用复制算法)auto              
			-  [4.3.3 Parallel Scavenge收集器（使用复制算法）](#433-parallel-scavenge收集器使用复制算法)auto            
		- [4.4 老年代的收集器](#44-老年代的收集器)auto               
 			- [4.4.1 Serial Old(标记整理算法)](#441-serial-old标记整理算法)auto               
  			- [4.4.2 ParOld收集器（标记整理算法）](#442-parold收集器标记整理算法)auto          
   			- [4.4.3 CMS收集器（标记清除）【重要】](#443-cms收集器标记清除重要)auto            
  			- [4.4.4 Garbage First收集器（复制 +标记+整理算法）](#444-garbage-first收集器复制-标记整理算法)auto       
 - [5. object的finalize()方法](#5-object的finalize方法)auto- [UNDO](#undo)auto       
 -   [6. 引用](#6-引用)autoauto<!-- /TOC -->


> JAVA自带的GC垃圾回收让我们不用考虑垃圾回收的问题，但是我们也需要了解他回收的原理,栈帧由于方法运行结束之后，自动释放。所以基本不需要我们考虑回收问题，堆则成了GC回收垃圾的主战场，因此也称堆为GC堆



## 1. 堆的存储结构 
 1.6 1.7之前，堆结构由新生代，老年代，永久代构成

![](https://s2.ax1x.com/2019/05/24/VirM7V.png)

1.8之后删去了永久代结构 
![](https://s2.ax1x.com/2019/05/24/VirlkT.png)


只保留了新生代与老年代结构 


> 
> 
> 
> 老生代中存储的基本都为新创建的对象，他们的存活率也很低。但是如果他们存活使用到一定的次数，就会进入老年代 ，而大对象（数组，字符串）则直接创建在老年代，理由后边会解释 。
> 
> 因次，新生代中存储的多为 新创建的对象。老年代中有三种，第一种是长期存活的进入老年代，第二种是新创建的大对象直接创建在老年代，第三种是新生代存放不下的对象。


<bR>

## 2. 如何判定他为垃圾？

> 
> 我们一般认为一个对象，不存在指向他的引用，那么就认为这是垃圾。一个常量的话没有引用指向他，例如常量池中有 "abc"，没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量。一个没有的类则需要满足三个条件 ：1.没有被引用，没有被反射访问 2.实例已回收 3. classloader被销毁

 
### 2.1 判断垃圾的算法 


####2.1.1 引用计数算法： 


> 通过判断对象的引用数量来判断，一个对象实例中会有一个引用计数器，每有一个引用了该对象，就使其+1,一个引用完成就使其-1，当其为0时就说明没有引用，就判定为垃圾。他执行效率高，程序受影响小，但是循环引用的情况解决不了，容易造成内存泄漏。


    class c1{

         c2 c2;
	}

	class c2{

         c1 c1;
	}

    public class test{

        public class static void main(String []args){
 			c2 c2 =new c2();
			c1 c1 =new c1();
			c1.c2 =c2;
			c2.c1=c1;

		}

	}


		


>       

#### 2.1.2. 可达性分析算法：


<br>

> 通过判断对象的引用链能到达来决定对象是否可以被回收。如下图，根目录到达不了5，因此他们都将被回收

![](https://s2.ax1x.com/2019/05/24/ViW3QO.jpg)

>那么什么对象作为根目录呢？
> 
> ①栈中的对象引用对象 
> ②方法区中的对象引用对象
> ③常量池中的对象引用对象
> ④本地方法的对线引用对象 
> ⑤活跃线程的引用对象

<br>
### 3. 垃圾回收的算法 

#### 3.1 标记清除算法

> 从根集合进行扫描，将存活的对象标记。然后按照堆的结构线性遍历，删去不可达的对象的内存【会造成碎片化】

<br>

#### 3.2 复制算法（重要）
> 将内存分为对象面与空闲面，对象创建在对象面上，进行垃圾回收的时候。将存活的对象复制到控线面上，然后将整个对象面清空。【一般都用于清理年轻代，会造成50%的空闲，适用于对象存活率低的情况，因为对象存活率太高，频繁的复制会降低效率，因此大对象直接创建在老生代中】

<br>

#### 3.3 标记整理算法（重要）
> 从根集合进行扫描，将存活的对象标记。然后将存活对象按照地址顺序排列在一起压缩到一段，然后将其他区域清空。【一般用于存活率极高的场景，比如老年代】

<br>

#### 3.4 分代收集算法 
>根据对象的生存周期不同将对象存储在不同的区域，根据不同的区域使用不同垃圾回收机制

<br>


年轻代使用Minor GC进行内存回收 
老年代使用Full  GC进行内存回收 

##### 3.4.1 分配存储机制
![](https://s2.ax1x.com/2019/05/24/VistPS.png)

>如图，我们一般将堆的新生代，老年代比例分为1:2 因为老年代会存放一些大的对象比如数组字符串，所以大一些 
> 
> 新生代则分为 Eden from to
> 
> Eden :伊甸园，基本上所有新创建的对象都在Eden区
> 
> survior from to :当Eden存储不下时候会少量存储对象，他主要是用来存储存活下来的对象的。 如果都存储不下甚至可以放在老年代

<br>

##### 3.4.2 Minor GC回收机制（回收年轻代）
> 如下图：当Eden中存储满了，survivor from中也存储了一部分对象


![](https://s2.ax1x.com/2019/05/24/Vio6mT.png)

> 然后调用垃圾处理机制,每部分只留下存活的对象 

![](https://s2.ax1x.com/2019/05/24/ViTV9s.png)
>然后将每部分存活的对象一起移动到survior中连续的区域,这样就有效的避免了碎片化

![](https://s2.ax1x.com/2019/05/24/ViTAhj.png)

<br>

##### 3.4.3 为什么要创建两个survior区域 ？

> 
> 提出这个问题，潜台词就是为什么不创建一个或者零个。
>
> 如果不创建的话，存活下来的对象就要放到老年代中。我们知道新生代的存活率是很低的，所以说他在一次存活下来，我们也无法确定他下一次是否能存活，而且下一次大概率很难存活。但是到了老生代，他们的回收机制不同，回收频率也很低，就很容易造成内存泄漏。

*内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。*

>如果只创建一个，如果发生了上边图中第一个的图的情况，Even存储已满，survivor中也存储了一部分，然后经过垃圾回收变成第二个图的情况，然后对其进行存活对象合并,但是结果是这样的，他会产生碎片化，严重降低性能。

![](https://s2.ax1x.com/2019/05/24/ViHPYQ.png)


##### 3.4.4 常见性能调优参数 

 
> 
>  -XX:SurvirorRatio: Eden和Surviror的比值，默认为8:1
> 
>  -XX：NewRatio: 老年代与新生代内存大小的比例
> 
>  -XX:MaxTenuringThreshold: 对象从新生代到老年代经过的最大阈值


##### 3.4.5 full GC与Major GC

> 
> full GC: 触发老年代垃圾回收也会伴随对新生代的垃圾回收，即整个堆的垃圾回收
> 
> Major GC: 可以指full GC 通常指只回收老年代 
> 
> full  GC的速率要低 一般会比major GC慢十倍，但是他的执行频率很低 


##### 3.4.6 触发full GC的条件 
> 
> 老年代空间不足：创建一个大对象，Eden对象空间不足，老年代空间也不足 
> 
> 永久代空间不足：（JDK 7以前） 类信息方法信息很多，就会触发full GC 在8以后也是因为这个去除永久代的原因，降低gc频率
> 
> CMS GC 出现 promotion failed(创建一个大对象，Eden对象空间不足，老年代空间也不足 )， concurrent mode failure(执行CMS时候，同时有对象要放入老年代，老年代空间不足) [CMS后边会讲]
> 
> 统计晋升的老年代的平均大小大于老年代的剩余空间
> 
> 调用system.gc 【只是提醒系统要回收了，具体什么时候回收不知道】

<br>

### 4. 垃圾收集器(收集算法的应用与强化)

首先我们需要了解两个概念。


> Stop -the -World 。这表示JVM由于要执行GC而停止了应用程序的执行， 在任何一种算法中都会发生，除了gc的线程，其他线程都暂停我们很多时候说的优化就是指减少stop -the =world，而使系统具有高吞吐，低停顿的特点。

> Safe -point:安全点，往往是GC执行的点。就比如保洁清洁教室，他为了避免刚刚清理，又有人扔垃圾的情况。他往往要求在清理垃圾的是其他人不得入内。安全点也是这个道理，如果gc在清理对象，对象的引用又在发生变化，就会造成清理不干净，安全点就是指不会发生对象引用关系变化的点。产生的地方主要有，方法的调用，循环跳转，异常跳转等等，安全点选择不能太多也不能太少，太少GC等的时间太长，太多效率会降低。

<br>

#### 4.1 JVM运行模式

>
> JVM分为Server与Client两种模式，Client启动快（轻量级虚拟机），但是Server稳定后程序运行更快（重量级虚拟机 优化多）

<br>
> cmd窗口下执行 Java -version即可查看版本 

![](https://s2.ax1x.com/2019/05/24/VFSdbj.png)

<br>

#### 4.2 垃圾收集器之间的关系 

![](https://s2.ax1x.com/2019/05/24/VFktFH.png)



#### 4.3 年轻代的收集器  

##### 4.3.1 Serial收集器（使用复制算法）

> 单线程完成垃圾收集工作，必须暂停所有工作线程 
> 
> 简单高效，Client模式下默认的年轻代收集器 100M也就几十毫秒



![](https://s2.ax1x.com/2019/05/24/VFuOOA.png)

<br>

##### 4.3.2 ParNew收集器（使用复制算法）

> 多线程收集，其余的行为，特点与Serial一样
> 
> 单核执行效率不如Serial，多核下执行线程数等于CPU数（可以设置）
> 
> 他是Server模型下首选的年轻代收集器 【除了Serial,只有ParNew可以与CMS配合工作】

![](https://s2.ax1x.com/2019/05/24/VFKpY8.md.png)


<br>


##### 4.3.3 Parallel Scavenge收集器（使用复制算法）


**概念： **吞吐量 =用户运行代码时间/(用户运行代码时间+垃圾收集时间)

> 
> 多线程收集，更关注系统吞吐量 
> 
> Server模型下默认的年轻代收集器


<br>


#### 4.4 老年代的收集器

##### 4.4.1 Serial Old(标记整理算法)

> 单线程完成垃圾收集工作，必须暂停所有工作线程 
> 
> 简单高效，Client模式下默认的老年代收集器 100M也就几十毫秒

<br>

##### 4.4.2 ParOld收集器（标记整理算法）

> 多线程收集，吞吐量优先 
> 
> 单核执行效率不如Serial，多核下执行线程数等于CPU数（可以设置）
> 
> 他是Server模型下首选的年轻代收集器 【除了Serial,只有ParNew可以与CMS配合工作】


<br>

#### 4.4.3 CMS收集器（标记清除）【重要】
**第一款真正意义的并发收集器**
>
>对停顿敏感，内存大的设备，有较多存活的对象时候有优势（他不用进行对象的频繁复制）。他主要分为六部
>
> 1.初始标记： stop-the-world 扫描根对象的直接子节点中的存活对象
> 
> 2.并发标记：其他线程回复正常运行，GC线程进行标记向下追溯
> 
> 3.并发预清理：查找并标记有没有新的新生代进入老年代 【相当于保洁打扫一半看看后边有没有同学丢垃圾】
> 
> 4.重新标记： stop-the-world 扫描剩余堆中的剩余对象【时间较长】
> 
> 5.并发清理：清理垃圾对象，其他线程再次期间是正常运行的
> 
> 6.并发重置：重置CMS收集器的数据结构

![](https://s2.ax1x.com/2019/05/24/VFM4PK.png)
<BR>


> 潜在问题：存在一边清理 一边丢垃圾的情况，如果垃圾在标记后产生，只能下一次清理。 并且他是标记清除，会造成碎片化，如果这时候要存入较大对象，就要调用GC
> 
> 
> 









<BR>


#### 4.4.4 Garbage First收集器（复制 +标记+整理算法）


> 
> 他是并发并行：并行指多个CPU缩短停顿时间【指标记的时候】，与用户线程并发执行
> 
> 分代收集：独立管理整个堆，采用不同方式处理不同区域的对象
> 
> 空间整理：它使用标记+整理算法 
> 
> 可预测停顿：可以设置系统收集垃圾的最大时间 




> 特点：
> 
> 他将老年代年轻代的严格界限释放掉，以大小相等Region形式存储，当出现较大文件时候，只需要移动部分的region,就可以完成存储 
> 

<BR>

### 5. object的finalize()方法 

> 一个对象并不一定是不被标记后马上释放的。如果这个对象继承了object的finalize方法,GC在第一次没标记到他时候并不马上释放而是存入F-Queue队列【优先级很低】，如果执行了之后他有了对象引用就不释放，否则就会释放。当然并不一定会执行到finalize方法 因为他的优先级很低，可能在这之前，对象的方法已经结束了。
> 
> 
> 
#UNDO
<BR>

###  6. 引用

>强引用： Object obj =new Object() 即使内存满了，也不会回收只会报错OutOfMemory 如果不用了设为null或者等他存货周期到了就回收了

> 软引用： 用于高速缓存，如果内存够就不回收，如果不够就回收 可以配合引用队列

>弱引用： 用于高速缓存，如果系统执行了GC就回收他 可以配合引用队列
>
> 虚引用：任何时候都能被回收，必须使用引用队列，是用来跟踪对象被回收的活动的


![](https://s2.ax1x.com/2019/05/24/VFKnYT.png)